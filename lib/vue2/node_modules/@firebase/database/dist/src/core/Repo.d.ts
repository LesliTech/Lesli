/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Path } from './util/Path';
import { AuthTokenProvider } from './AuthTokenProvider';
import { PersistentConnection } from './PersistentConnection';
import { RepoInfo } from './RepoInfo';
import { Database } from '../api/Database';
import { DataSnapshot } from '../api/DataSnapshot';
import { Query } from '../api/Query';
import { EventRegistration } from './view/EventRegistration';
import { Indexable } from './util/misc';
import { FirebaseAppLike } from './RepoManager';
export declare enum TransactionStatus {
    RUN = 0,
    SENT = 1,
    COMPLETED = 2,
    SENT_NEEDS_ABORT = 3,
    NEEDS_ABORT = 4
}
/**
 * A connection to a single data repository.
 */
export declare class Repo {
    repoInfo_: RepoInfo;
    private forceRestClient_;
    app: FirebaseAppLike;
    authTokenProvider_: AuthTokenProvider;
    /** Key for uniquely identifying this repo, used in RepoManager */
    readonly key: string;
    dataUpdateCount: number;
    private infoSyncTree_;
    private serverSyncTree_;
    private stats_;
    private statsListener_;
    private eventQueue_;
    private nextWriteId_;
    private server_;
    private statsReporter_;
    private infoData_;
    private interceptServerDataCallback_;
    private __database;
    /** A list of data pieces and paths to be set when this client disconnects. */
    private onDisconnect_;
    /** Stores queues of outstanding transactions for Firebase locations. */
    private transactionQueueTree_;
    persistentConnection_: PersistentConnection | null;
    constructor(repoInfo_: RepoInfo, forceRestClient_: boolean, app: FirebaseAppLike, authTokenProvider_: AuthTokenProvider);
    start(): void;
    /**
     * @return The URL corresponding to the root of this Firebase.
     */
    toString(): string;
    /**
     * @return The namespace represented by the repo.
     */
    name(): string;
    /**
     * @return The time in milliseconds, taking the server offset into account if we have one.
     */
    serverTime(): number;
    /**
     * Generate ServerValues using some variables from the repo object.
     */
    generateServerValues(): Indexable;
    /**
     * Called by realtime when we get new messages from the server.
     */
    private onDataUpdate_;
    interceptServerData_(callback: ((a: string, b: unknown) => unknown) | null): void;
    private onConnectStatus_;
    private onServerInfoUpdate_;
    private updateInfo_;
    private getNextWriteId_;
    /**
     * The purpose of `getValue` is to return the latest known value
     * satisfying `query`.
     *
     * This method will first check for in-memory cached values
     * belonging to active listeners. If they are found, such values
     * are considered to be the most up-to-date.
     *
     * If the client is not connected, this method will try to
     * establish a connection and request the value for `query`. If
     * the client is not able to retrieve the query result, it reports
     * an error.
     *
     * @param query - The query to surface a value for.
     */
    getValue(query: Query): Promise<DataSnapshot>;
    setWithPriority(path: Path, newVal: unknown, newPriority: number | string | null, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    update(path: Path, childrenToMerge: {
        [k: string]: unknown;
    }, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    /**
     * Applies all of the changes stored up in the onDisconnect_ tree.
     */
    private runOnDisconnectEvents_;
    onDisconnectCancel(path: Path, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    onDisconnectSet(path: Path, value: unknown, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    onDisconnectSetWithPriority(path: Path, value: unknown, priority: unknown, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    onDisconnectUpdate(path: Path, childrenToMerge: {
        [k: string]: unknown;
    }, onComplete: ((status: Error | null, errorReason?: string) => void) | null): void;
    addEventCallbackForQuery(query: Query, eventRegistration: EventRegistration): void;
    removeEventCallbackForQuery(query: Query, eventRegistration: EventRegistration): void;
    interrupt(): void;
    resume(): void;
    stats(showDelta?: boolean): void;
    statsIncrementCounter(metric: string): void;
    private log_;
    callOnCompleteCallback(callback: ((status: Error | null, errorReason?: string) => void) | null, status: string, errorReason?: string | null): void;
    get database(): Database;
    /**
     * Creates a new transaction, adds it to the transactions we're tracking, and
     * sends it to the server if possible.
     *
     * @param path Path at which to do transaction.
     * @param transactionUpdate Update callback.
     * @param onComplete Completion callback.
     * @param applyLocally Whether or not to make intermediate results visible
     */
    startTransaction(path: Path, transactionUpdate: (a: unknown) => unknown, onComplete: ((a: Error, b: boolean, c: DataSnapshot) => void) | null, applyLocally: boolean): void;
    /**
     * @param excludeSets A specific set to exclude
     */
    private getLatestState_;
    /**
     * Sends any already-run transactions that aren't waiting for outstanding
     * transactions to complete.
     *
     * Externally it's called with no arguments, but it calls itself recursively
     * with a particular transactionQueueTree node to recurse through the tree.
     *
     * @param node transactionQueueTree node to start at.
     */
    private sendReadyTransactions_;
    /**
     * Given a list of run transactions, send them to the server and then handle
     * the result (success or failure).
     *
     * @param path The location of the queue.
     * @param queue Queue of transactions under the specified location.
     */
    private sendTransactionQueue_;
    /**
     * Finds all transactions dependent on the data at changedPath and reruns them.
     *
     * Should be called any time cached data changes.
     *
     * Return the highest path that was affected by rerunning transactions. This
     * is the path at which events need to be raised for.
     *
     * @param changedPath The path in mergedData that changed.
     * @return The rootmost path that was affected by rerunning transactions.
     */
    private rerunTransactions_;
    /**
     * Does all the work of rerunning transactions (as well as cleans up aborted
     * transactions and whatnot).
     *
     * @param queue The queue of transactions to run.
     * @param path The path the queue is for.
     */
    private rerunTransactionQueue_;
    /**
     * Returns the rootmost ancestor node of the specified path that has a pending
     * transaction on it, or just returns the node for the given path if there are
     * no pending transactions on any ancestor.
     *
     * @param path The location to start at.
     * @return The rootmost node with a transaction.
     */
    private getAncestorTransactionNode_;
    /**
     * Builds the queue of all transactions at or below the specified
     * transactionNode.
     *
     * @param transactionNode
     * @return The generated queue.
     */
    private buildTransactionQueue_;
    private aggregateTransactionQueuesForNode_;
    /**
     * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.
     */
    private pruneCompletedTransactionsBelowNode_;
    /**
     * Aborts all transactions on ancestors or descendants of the specified path.
     * Called when doing a set() or update() since we consider them incompatible
     * with transactions.
     *
     * @param path Path for which we want to abort related transactions.
     */
    private abortTransactions_;
    /**
     * Abort transactions stored in this transaction queue node.
     *
     * @param node Node to abort transactions for.
     */
    private abortTransactionsOnNode_;
}
